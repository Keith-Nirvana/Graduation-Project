export const rules = [
  {
    key: '1',
    number: '1',
    name: '持续变化',
    detail: '一个软件系统在使用过程中必须经过不断的演化，否则它的功能在新的时间阶段就跟不上需求。当评估所得的修改成本大于重建新系统的成本时，旧系统就会被丢弃。应用类型的软件不仅会因需求的变化而对功能进行增减，而且会需要随着周围的环境变化而发生变化。',
  },
  {
    key: '2',
    number: '2',
    name: '复杂度增加',
    detail: '在演化过程中，软件系统的复杂性随之提高。项目的拥有者或领导者会利用诸如重构等优化措施，尽可能地将软件的复杂性保持在可控水平。然而，为了实现新的功能和适应不断变化的环境，代码终究会不断地被修改、添加和删除，这会导致系统的非结构化和代码质量的恶化，使代码过于复杂且难以理解。'
  },
  {
    key: '3',
    number: '3',
    name: '自我规范',
    detail: '软件系统的演化体现了特定的控制规律。它会受其内在约束的限制，并不完全取决于需求的变化。比如一款软件复杂性很高规模很大，那么就不可能在短时间发生巨大变化。它们处于相互制约、平衡的关系中。该规则最重要的价值在于证明软件演化中的存在的变化和整体趋势，并且这些内容可以用统计方法进行验证。'
  },
  {
    key: '4',
    number: '4',
    name: '组织稳定性的保持',
    detail: '也称为不变工作速率。这一规律与第五定律同时提出，从两个不同的角度描述了系统的稳定程度或者说活跃度。这一规律表明，由于项目组人员数量和单个人员工作效率相对稳定，整个工程的规模总统上的推进会趋于平稳。'
  },
  {
    key: '5',
    number: '5',
    name: '熟悉度的保持',
    detail: '这条法则不同于上一条从开发者的视角为中心的看法，它从用户和其他角色（如公司中的市场销售人员）的角度解释了这一问题。为了确保熟悉系统，相邻软件版本之间的差异不应太大。目前一种常见的方法是低频次地发布大版本更新，并将很多小版本发布在大版本之后，以避免对软件的熟悉程度失去控制。'
  },
  {
    key: '6',
    number: '6',
    name: '持续增长',
    detail: '第一条法则概括地描述了软件演化的主要特征，而这第六条法则则强调说明软件系统的功能数量会持续增长。本法则中所提到的新增功能来源于需求规范的修改与增加，而不是考虑像提高代码质量那些软件自身优化的需求。'
  },{
    key: '7',
    number: '7',
    name: '质量下降',
    detail: '与现实情况一样，这条法则常被视为其他法则的必然结果。自从软件的第一个版本发行之后，除非付出了巨大的努力，否则代码的质量将不可避免地下降。这是一系列对项目修改的结果，有些修改是以非计划性补丁的方式进行的，这更加剧了代码质量的恶化。这条法则经常与第二条法则结合来看，因为它们都提到质量问题。'
  },
  {
    key: '8',
    number: '8',
    name: '反馈制度',
    detail: '反馈系统与第三定律有着密切的联系。这一规律揭示了软件系统在某一阶段的演化将影响到下一阶段的演化。换句话说，演化过程有其内在的局限性。根据Lehman的研究，整个软件开发组织可以看作是一个多层次的反馈系统，因为它包含一个多层级的管理和反映体系。'
  },

];